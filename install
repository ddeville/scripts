#!/usr/bin/env python

import argparse
import json
import os
import shutil
import subprocess

try:
    from urllib.request import urlretrieve
except ImportError:
    from urllib import urlretrieve

from py.package_manager import (
    PackageType,
    create_package_manager,
)
from py.platform import (
    FREEBSD,
    LINUX,
    MACOS,
    get_current_platform,
)
from py.task_executor import (
    ExecutorConfig,
    TaskManifest,
    print_all_tasks_for_config,
    run_all_tasks_for_config,
)
from py.util import (
    change_dir,
    command_path,
    copy_file,
    create_dirs,
    force_symlink,
    is_cmd_installed,
    run_command,
    run_script_as_root,
)

SCRIPTS_PATH = os.path.dirname(os.path.realpath(__file__))
ALL_PLATFORMS = [MACOS, LINUX, FREEBSD]
FULL = "full"

# Packages

COMMON_PACKAGES = [
    "fish",
    "tmux",
    "mosh",
    "jq",
    "htop",
    "ripgrep",
    "tree",
    "vim",
    "vifm",
]

COMMON_PACKAGES_FULL = [
    "cmake",  # for ycm
    "radare2",
]

EXTRA_PACKAGES = {
    PackageType.BREW: [
        "ctags",
        "fd",
    ],
    PackageType.PACMAN: [
        "ctags",
        "fd",
    ],
    PackageType.DEB: [
        "exuberant-ctags",
}

EXTRA_PACKAGES_FULL = {
    PackageType.BREW: [
        "hyperfine",
        "golang",
        "node",
    ],
    PackageType.PACMAN: [
        "ttf-anonymous-pro",
    ],
    PackageType.DEB: [
        "ttf-anonymous-pro",
        "build-essential",  # for ycm
        "python-dev",  # for ycm
        "python3-dev",  # for ycm
    ],

}

# Tasks

def task_install_package_manager():
    # type: () -> TaskManifest
    def cmd():
        package_manager = create_package_manager()
        package_manager.install()

    return TaskManifest(cmd=cmd, tags=ALL_PLATFORMS, dependencies=[])

def task_install_packages():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        package_manager = create_package_manager()
        for package in COMMON_PACKAGES + EXTRA_PACKAGES.get(package_manager.format(), []):
            package_manager.install_package(package)

    return TaskManifest(cmd=cmd, tags=ALL_PLATFORMS, dependencies=["install_package_manager"])

def task_install_packages_full():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        package_manager = create_package_manager()
        for package in COMMON_PACKAGES_FULL + EXTRA_PACKAGES_FULL.get(package_manager.format(), []):
            package_manager.install_package(package)

    return TaskManifest(cmd=cmd, tags=ALL_PLATFORMS + [FULL], dependencies=["install_package_manager"])

def task_update_shell():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        shell_path = command_path("fish")
        assert shell_path is not None, "Cannot find shell path"

        # let's check whether fish was added to /etc/shells
        with open("/etc/shells") as f:
            if not shell_path in f.read():
                # we need to add fish to /etc/shells
                print("====> adding fish to /etc/shells")
                script = "#!/bin/sh\necho \"%s\" >> /etc/shells" % shell_path
                run_script_as_root(script)
            else:
                print("====> fish already in /etc/shells")

        # next let's check whether we need to change the shell
        if os.environ.get("SHELL") != shell_path:
            print("====> changing shell to fish")
            run_command(["chsh", "-s", shell_path])
        else:
            print("====> fish is already default shell")

    return TaskManifest(cmd=cmd, tags=ALL_PLATFORMS, dependencies=["install_packages"])

def task_install_base16():
    # type: () -> TaskManifest
    repos = [
        ("base16-shell", "https://github.com/chriskempson/base16-shell.git"),
    ]
    def cmd():
        # type: () -> None
        for name, repo_url in repos:
            path = os.path.expanduser(os.path.join("~", ".config", name))
            # first remove the existing repo if it exists
            if os.path.exists(path):
                print("====> deleting existing %s repo" % name)
                shutil.rmtree(path)
            # second, clone the repo in the right place
            print("====> installing %s repo" % name)
            run_command(["git", "clone", repo_url, path])

    return TaskManifest(cmd=cmd, tags=ALL_PLATFORMS, dependencies=["update_shell"])

def task_update_dot_files():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        orig_dir = os.path.join(SCRIPTS_PATH, "config")
        dest_dir = os.path.expanduser("~")

        links = [
            ("bash_profile", ".bash_profile"),
            ("bashrc", ".bashrc"),
            ("ctags", ".ctags"),
            ("gitconfig", ".gitconfig"),
            ("hushlogin", ".hushlogin"),
            ("lldbinit", ".lldbinit"),
            ("profile", ".profile"),
            ("tmux.conf", ".tmux.conf"),
            ("vim", ".vim"),
            ("vimrc", ".vimrc"),
            ("fish", os.path.join(".config", "fish")),
            (os.path.join("vifm", "vifmrc"), os.path.join(".config", "vifm", "vifmrc")),
            (os.path.join("vifm", "colors"), os.path.join(".config", "vifm", "colors")),
            (os.path.join("htop", "htoprc"), os.path.join(".config", "htop", "htoprc")),
        ]

        # make sure that we create the various `.config/xxx` directories since they won't be here on new machines
        create_dirs(os.path.join(dest_dir, ".config", "vifm"))
        create_dirs(os.path.join(dest_dir, ".config", "htop"))

        print("====> linking dot files")
        for f1, f2 in links:
            force_symlink(os.path.join(orig_dir, f1), os.path.join(dest_dir, f2))

    return TaskManifest(cmd=cmd, tags=ALL_PLATFORMS, dependencies=["install_base16"])

def task_install_pyenv():
    # type: () -> TaskManifest
    def cmd():
        if is_cmd_installed("pyenv"):
            print("====> updating pyenv")
            run_command(["pyenv", "update"])
        else:
            pyenv_path = os.path.expanduser("~/.pyenv")
            if os.path.exists(pyenv_path):
                print("====> deleting existing pyenv install")
                shutil.rmtree(pyenv_path)
            print("====> installing pyenv")
            pyenv_installer_path = "https://raw.githubusercontent.com/pyenv/pyenv-installer/master/bin/pyenv-installer"
            script_path, _ = urlretrieve(pyenv_installer_path)
            run_command(["bash", script_path])

    return TaskManifest(cmd=cmd, tags=ALL_PLATFORMS + [FULL], dependencies=["update_dot_files"])

def task_install_rustup():
    # type: () -> TaskManifest
    def cmd():
        if is_cmd_installed("rustup"):
            print("====> updating rustup")
            run_command(["rustup", "self", "update"])
        else:
            print("====> install rustup")
            script_path, _ = urlretrieve("https://sh.rustup.rs")
            run_command(["sh", script_path, "-y", "--no-modify-path"])
        pass

    return TaskManifest(cmd=cmd, tags=ALL_PLATFORMS + [FULL], dependencies=["update_dot_files"])

def task_update_tmux_plugins():
    # type: () -> TaskManifest
    def cmd():
        tpm_path = os.path.expanduser("~/.tmux/plugins/tpm")

        # first install TPM itself if needed
        if not os.path.exists(tpm_path):
            print("====> installing TPM")
            run_command(["git", "clone", "https://github.com/tmux-plugins/tpm", tpm_path])

        # and update the plugins
        print("====> updating tmux plugins")
        run_command([os.path.join(tpm_path, "bin", "install_plugins")])
        run_command([os.path.join(tpm_path, "bin", "update_plugins"), "all"])

    return TaskManifest(cmd=cmd, tags=ALL_PLATFORMS, dependencies=["update_dot_files"])

def task_update_vim_plugins():
    # type: () -> TaskManifest
    def cmd():
        print("====> updating vim plugins")
        # update vim-plug itself
        run_command(["vim", "+PlugUpgrade", "+qall"])
        # install or update all plugins
        run_command(["vim", "+PlugUpdate", "+qall"])

    return TaskManifest(cmd=cmd, tags=ALL_PLATFORMS, dependencies=["update_dot_files", "install_rustup"])

def task_build_vim_plugins():
    # type: () -> TaskManifest
    try:
        from json import JSONDecodeError
    except ImportError:
        JSONDecodeError = ValueError  # python 2...

    def _load_build_cache(path):
        # type: (str) -> Dict[str, str]
        try:
            with open(path) as f:
                build_cache = json.load(f)
        except (IOError, JSONDecodeError):
            build_cache = {}
        return build_cache

    def _write_build_cache(path, build_cache):
        # type: (str, Dict[str, str]) -> None
        with open(path, "w") as f:
            json.dump(build_cache, f)

    def cmd():
        # type: () -> None
        plugins_path = os.path.expanduser("~/.vim-plug-plugins")

        # load the config that contains the git hash of the last time we built
        build_cache_path = os.path.join(plugins_path, "build_cache.json")
        build_cache = _load_build_cache(build_cache_path)

        plugin = "YouCompleteMe"
        with change_dir(os.path.join(plugins_path, plugin)):
            # get the hash of the current commit so that we can check whether we need to rebuild
            cur_hash = subprocess.check_output(["git", "rev-parse", "--verify", "HEAD"]).strip().decode()

            if cur_hash != build_cache.get(plugin):
                print("====> building ycm")
                # make sure that cargo is on the path since we might have just changed the shell...
                env = os.environ.copy()
                env["PATH"] = os.path.expanduser("~/.cargo/bin") + ":" + env["PATH"]
                # we want to use the system python since pyenv might not include the python dylib...
                if os.path.isfile("/usr/bin/python3"):
                    python_path = "/usr/bin/python3"
                elif os.path.isfile("/usr/local/bin/python3"):
                    python_path = "/usr/local/bin/python3"
                elif os.path.isfile("/usr/bin/python"):
                    python_path = "/usr/bin/python"
                elif os.path.isfile("/usr/local/bin/python"):
                    python_path = "/usr/local/bin/python"
                else:
                    python_path = "python"
                completers = [
                    "--clang-completer",
                    "--clangd-completer",
                    "--rust-completer",
                ]
                # on mac, we also install node and go so install the completers
                if get_current_platform() == MACOS:
                    completers += [
                        "--go-completer",
                        "--ts-completer",
                    ]
                run_command([python_path, "install.py"] + completers, env=env)
                # cache the git hash that we've just built
                build_cache[plugin] = cur_hash
            else:
                print("====> ycm already built")

        _write_build_cache(build_cache_path, build_cache)

    return TaskManifest(cmd=cmd, tags=ALL_PLATFORMS + [FULL], dependencies=["update_vim_plugins"])

def task_update_library_visibility():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        print("====> updating ~/Library visibility")
        nohidden_flag = 1 << 15
        library_path = os.path.expanduser("~/Library")
        library_stat = os.stat(library_path)
        os.chflags(library_path, library_stat.st_flags & ~nohidden_flag)

    return TaskManifest(cmd=cmd, tags=[MACOS, FULL], dependencies=["update_dot_files"])

def task_update_system_preferences():
    # type: () -> TaskManifest
    def update_prefs(key, val, domain="NSGlobalDomain"):
        # type: (str, str) -> None
        run_command(["defaults", "write", domain, key, val])

    def cmd():
        # type: () -> None
        print("====> updating system preferences")
        update_prefs("NSShowAppCentricOpenPanelInsteadOfUntitledFile", "0")
        update_prefs("NSQuitAlwaysKeepsWindows", "1")
        update_prefs("TALLogoutSavesState", "1", "com.apple.loginwindow")
        # text
        update_prefs("NSAutomaticSpellingCorrectionEnabled", "0")
        update_prefs("NSAutomaticCapitalizationEnabled", "0")
        update_prefs("NSAutomaticDashSubstitutionEnabled", "0")
        update_prefs("NSAutomaticPeriodSubstitutionEnabled", "0")
        update_prefs("NSAutomaticQuoteSubstitutionEnabled", "0")
        update_prefs("NSAutomaticTextCompletionEnabled", "0")
        # key repeat
        # update_prefs("KeyRepeat", "2")
        # update_prefs("InitialKeyRepeat", "15")
        update_prefs("ApplePressAndHoldEnabled", "0")
        # hot corners
        # update_prefs("wvous-bl-corner", "4", "com.apple.dock")
        # update_prefs("wvous-bl-modifier", "0", "com.apple.dock")
        # update_prefs("wvous-br-corner", "3", "com.apple.dock")
        # update_prefs("wvous-br-modifier", "0", "com.apple.dock")
        # update_prefs("wvous-tl-corner", "11", "com.apple.dock")
        # update_prefs("wvous-tl-modifier", "0", "com.apple.dock")
        # update_prefs("wvous-tr-corner", "2", "com.apple.dock")
        # update_prefs("wvous-tr-modifier", "0", "com.apple.dock")

    return TaskManifest(cmd=cmd, tags=[MACOS, FULL], dependencies=["update_dot_files"])

def task_update_iterm_sync_folder_prefs():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        print("====> updating iterm preferences")
        run_command(["defaults", "write", "com.googlecode.iterm2", "PrefsCustomFolder",
            os.path.join(SCRIPTS_PATH, "macos", "iterm")])

    return TaskManifest(cmd=cmd, tags=[MACOS, FULL], dependencies=["update_dot_files"])

def task_install_fonts():
    # type: () -> TaskManifest
    def cmd():
        print("====> installing fonts")
        fonts_path = os.path.join(SCRIPTS_PATH, "fonts")
        dest_path = os.path.join(os.path.expanduser("~"), "Library", "Fonts")
        create_dirs(dest_path)
        for folder in os.listdir(fonts_path):
            font_path = os.path.join(fonts_path, folder)
            if os.path.isdir(font_path) and not folder.startswith("."):
                copy_file(font_path, os.path.join(dest_path, folder), True)

    return TaskManifest(cmd=cmd, tags=[MACOS, FULL], dependencies=["update_dot_files"])

def task_install_xcode_themes():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        print("====> installing xcode themes")
        themes_path = os.path.join(SCRIPTS_PATH, "macos", "xcode")
        dest_path = os.path.join(os.path.expanduser("~"), "Library", "Developer", "Xcode", "UserData",
                                 "FontAndColorThemes")
        create_dirs(dest_path)
        for theme in os.listdir(themes_path):
            theme_path = os.path.join(themes_path, theme)
            if not theme.startswith("."):
                copy_file(theme_path, os.path.join(dest_path, theme))

    return TaskManifest(cmd=cmd, tags=[MACOS, FULL], dependencies=["update_dot_files"])

# Main

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Install scripts on the current system.")
    parser.add_argument("action", choices=["list", "run"], help="whether to list the tasks or actually run them")
    parser.add_argument("-p", "--platform", action="store", help="the platform to use")
    parser.add_argument("-f", "--full", action="store_false", help="whether a full install should be performed")
    args = parser.parse_args()

    module_name = __name__
    tags = []

    if args.full:
        tags.append(FULL)

    platform = args.platform if args.platform else get_current_platform()
    assert platform in ALL_PLATFORMS, "Unknown platform: %s" % platform
    tags.append(platform)

    config = ExecutorConfig(module_name, tags)

    if args.action == "list":
        print_all_tasks_for_config(config)
    elif args.action == "run":
        run_all_tasks_for_config(config)

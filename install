#!/usr/bin/env python

import argparse
import os
import subprocess
import sys
import urllib

from py.executor import (
    ExecutorConfig,
    TaskManifest,
    print_all_tasks_for_config,
    run_all_tasks_for_config,
)
from py.util import (
    change_dir,
    copy_file_if_needed,
    create_dirs_if_needed,
    force_symlink,
    is_cmd_installed,
    run_command,
    run_command_no_output,
    run_script_as_root,
)

SCRIPTS_PATH = os.path.dirname(os.path.realpath(__file__))

# Tags

MACOS = "macos"
LINUX = "linux"
ALL_PLATFORMS = [MACOS, LINUX]
BASIC = "basic"

# Packages

PACKAGES = [
    "fish",
    "tmux",
    "mosh",
    "jq",
    "radare2",
    "cmake",  # for YouCompleteMe
]

PACKAGES_MACOS = [
    "the_silver_searcher",
    "tree",
]

PACKAGES_LINUX = [
    "silversearcher-ag",
    "ttf-anonymous-pro",
    "vim",
    "python-dev",  # for YouCompleteMe
    "python3-dev",
    "build-essential",
]

# Tasks

def task_install_brew_if_needed():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        if is_cmd_installed("brew"):
            print("====> brew already installed")
        else:
            script_path, _ = urllib.urlretrieve("https://raw.githubusercontent.com/Homebrew/install/master/install")
            u["/usr/bin/ruby", script_path])

    return TaskManifest(cmd=cmd, tags=[MACOS, BASIC], dependencies=[])

def task_update_apt_get_if_needed():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        print("====> updating package manager")
        run_command(["sudo", "apt-get", "update", "--fix-missing"])

    return TaskManifest(cmd=cmd, tags=[LINUX, BASIC], dependencies=[])

def task_install_brew_formulas_if_needed():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        for package in PACKAGES + PACKAGES_MACOS:
            print("====> installing %s" % package)
            try:
                print("====> checking status of %s" % package)
                run_command(["brew", "ls", "--versions", package])
                # if the previous call succeeded, the package is installed so upgrade
                print("====> %s installed, upgrading" % package)
                try:
                    run_command_no_output(["brew", "upgrade", package])
                except subprocess.CalledProcessError:
                    print("====> %s up to date" % package)
            except subprocess.CalledProcessError:
                # the package has never been installed, do that now
                print("====> installing %s" % package)
                try:
                    run_command(["brew", "install", package])
                except subprocess.CalledProcessError:
                    # brew install succeeds by returning a status code of 1...
                    pass
            print("====> %s linking" % package)
            run_command_no_output(["brew", "link", package])

    return TaskManifest(cmd=cmd, tags=[MACOS, BASIC], dependencies=["install_brew_if_needed"])

def task_install_linux_packages_if_needed():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        for package in PACKAGES + PACKAGES_LINUX:
            print("====> installing %s" % package)
            run_command(["sudo", "apt-get", "upgrade", package])

    return TaskManifest(cmd=cmd, tags=[LINUX, BASIC], dependencies=["update_apt_get_if_needed"])

def task_update_shell_macos_if_needed():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        # let's check whether fish was added to /etc/shells
        with open("/etc/shells") as f:
            if not "/usr/local/bin/fish" in f.read():
                # we need to add fish to /etc/shells
                print("====> adding fish to /etc/shells")
                script = "#!/bin/bash\necho \"/usr/local/bin/fish\" >> /etc/shells"
                run_script_as_root(script)
            else:
                print("====> fish already in /etc/shells")

        # next let's check whether we need to change the shell
        if os.environ.get("SHELL") != "/usr/local/bin/fish":
            print("====> changing shell to fish")
            run_command(["chsh", "-s", "/usr/local/bin/fish"])
        else:
            print("====> fish is already default shell")

    return TaskManifest(cmd=cmd, tags=[MACOS, BASIC], dependencies=["install_brew_formulas_if_needed"])

def task_update_shell_linux_if_needed():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        if os.environ.get("SHELL") != "/usr/bin/fish":
            print("====> changing shell to fish")
            run_command(["chsh", "-s", "/usr/bin/fish"])
        else:
            print("====> fish is already default shell")

    return TaskManifest(cmd=cmd, tags=[LINUX, BASIC], dependencies=["install_linux_packages_if_needed"])

def task_update_dot_files():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        orig_dir = os.path.join(SCRIPTS_PATH, "config")
        dest_dir = os.path.expanduser("~")

        links = [
            ("hushlogin", ".hushlogin"),
            ("bash_profile", ".bash_profile"),
            ("bashrc", ".bashrc"),
            ("lldbinit", ".lldbinit"),
            ("gitconfig", ".gitconfig"),
            ("profile", ".profile"),
            ("vim", ".vim"),
            ("vimrc", ".vimrc"),
            ("tmux.conf", ".tmux.conf"),
            (os.path.join("fish", "config.fish"), os.path.join(".config", "fish", "config.fish")),
            (os.path.join("fish", "functions"), os.path.join(".config", "fish", "functions")),
        ]

        # make sure that we create the `.config/fish` directory since it won't be here on new machines
        create_dirs_if_needed(os.path.join(dest_dir, ".config", "fish"))

        print("====> linking dot files")
        for f1, f2 in links:
            force_symlink(os.path.join(orig_dir, f1), os.path.join(dest_dir, f2))

    return TaskManifest(cmd=cmd, tags=(ALL_PLATFORMS + [BASIC]),
            dependencies=["update_shell_macos_if_needed", "update_shell_linux_if_needed"])

def task_update_vim_plugins():
    # type: () -> TaskManifest
    def cmd():
        print("====> updating vim plugins")
        # update vim-plug itself
        run_command(["vim", "+PlugUpgrade", "+qall"])
        # install or update all plugins
        run_command(["vim", "+PlugUpdate", "+qall"])

    return TaskManifest(cmd=cmd, tags=(ALL_PLATFORMS + [BASIC]), dependencies=["update_dot_files"])

def task_update_tmux_plugins():
    # type: () -> TaskManifest
    def cmd():
        tpm_path = os.path.expanduser("~/.tmux/plugins/tpm")

        # first install TPM itself if needed
        if not os.path.exists(tpm_path):
            print("====> installing TPM")
            run_command(["git", "clone", "https://github.com/tmux-plugins/tpm", tpm_path])

        # and update the plugins
        print("====> updating tmux plugins")
        run_command([os.path.join(tpm_path, "bin", "install_plugins")])
        run_command([os.path.join(tpm_path, "bin", "update_plugins"), "all"])

    return TaskManifest(cmd=cmd, tags=(ALL_PLATFORMS + [BASIC]), dependencies=["update_dot_files"])

def task_install_pyenv():
    # type: () -> TaskManifest
    def cmd():
        if is_cmd_installed("pyenv"):
            print("====> updating pyenv")
            run_command_no_output(["pyenv", "update"])
        else:
            print("====> installing pyenv")
            script_path, _ = urllib.urlretrieve("https://raw.githubusercontent.com/pyenv/pyenv-installer/master/bin/pyenv-installer")
            run_command(["bash", script_path])

    return TaskManifest(cmd=cmd, tags=ALL_PLATFORMS, dependencies=["update_dot_files"])

def task_install_rustup():
    # type: () -> TaskManifest
    def cmd():
        if is_cmd_installed("rustup"):
            print("====> updating rustup")
            run_command_no_output(["rustup", "self", "update"])
        else:
            print("====> install rustup")
            script_path, _ = urllib.urlretrieve("https://sh.rustup.rs")
            run_command(["sh", script_path])
        pass

    return TaskManifest(cmd=cmd, tags=ALL_PLATFORMS, dependencies=["update_dot_files"])

def task_build_you_complete_me():
    # type: () -> TaskManifest
    def cmd():
        print("====> building YouCompleteMe")
        with change_dir(os.path.expanduser("~/.vim-plug-plugins/YouCompleteMe")) as path:
            run_command(["/usr/bin/python", "install.py", "--clang-completer", "--rust-completer"])

    return TaskManifest(cmd=cmd, tags=ALL_PLATFORMS, dependencies=["update_vim_plugins", "install_rustup"])

def task_update_library_visibility():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        print("====> updating ~/Library visibility")
        nohidden_flag = 1 << 15
        library_path = os.path.expanduser("~/Library")
        library_stat = os.stat(library_path)
        os.chflags(library_path, library_stat.st_flags & ~nohidden_flag)

    return TaskManifest(cmd=cmd, tags=[MACOS], dependencies=["update_dot_files"])

def task_update_system_preferences():
    # type: () -> TaskManifest
    def update_prefs(key, val, domain="NSGlobalDomain"):
        # type: (str, str) -> None
        run_command_no_output(["defaults", "write", domain, key, val])

    def cmd():
        # type: () -> None
        print("====> updating system preferences")
        update_prefs("NSShowAppCentricOpenPanelInsteadOfUntitledFile", "0")
        update_prefs("NSQuitAlwaysKeepsWindows", "1")
        update_prefs("NSAutomaticSpellingCorrectionEnabled", "0")
        update_prefs("NSAutomaticCapitalizationEnabled", "0")
        update_prefs("NSAutomaticDashSubstitutionEnabled", "0")
        update_prefs("NSAutomaticPeriodSubstitutionEnabled", "0")
        update_prefs("NSAutomaticQuoteSubstitutionEnabled", "0")
        update_prefs("NSAutomaticTextCompletionEnabled", "0")
        update_prefs("slowKey", "0", "com.apple.universalaccess")
        update_prefs("KeyRepeat", "2")
        update_prefs("InitialKeyRepeat", "15")
        update_prefs("ApplePressAndHoldEnabled", "0")
        update_prefs("TALLogoutSavesState", "1", "com.apple.loginwindow")

    return TaskManifest(cmd=cmd, tags=[MACOS], dependencies=["update_dot_files"])

def task_update_iterm_sync_folder_prefs():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        print("====> updating iterm preferences")
        run_command_no_output(["defaults", "write", "com.googlecode.iterm2", "PrefsCustomFolder",
                                os.path.join(SCRIPTS_PATH, "macos", "iterm")])

    return TaskManifest(cmd=cmd, tags=[MACOS], dependencies=["update_dot_files"])

def task_install_fonts():
    # type: () -> TaskManifest
    def cmd():
        print("====> installing fonts")
        fonts_path = os.path.join(SCRIPTS_PATH, "fonts")
        dest_path = os.path.join(os.path.expanduser("~"), "Library", "Fonts")
        create_dirs_if_needed(dest_path)
        for folder in os.listdir(fonts_path):
            font_path = os.path.join(fonts_path, folder)
            if os.path.isdir(font_path) and not folder.startswith("."):
                copy_file_if_needed(font_path, os.path.join(dest_path, folder), True)

    return TaskManifest(cmd=cmd, tags=[MACOS], dependencies=["update_dot_files"])

def task_install_xcode_themes():
    # type: () -> TaskManifest
    def cmd():
        # type: () -> None
        print("====> installing xcode themes")
        themes_path = os.path.join(SCRIPTS_PATH, "macos", "xcode")
        dest_path = os.path.join(os.path.expanduser("~"), "Library", "Developer", "Xcode", "UserData",
                                 "FontAndColorThemes")
        create_dirs_if_needed(dest_path)
        for theme in os.listdir(themes_path):
            theme_path = os.path.join(themes_path, theme)
            if not theme.startswith("."):
                copy_file_if_needed(theme_path, os.path.join(dest_path, theme))

    return TaskManifest(cmd=cmd, tags=[MACOS], dependencies=["update_dot_files"])

# Private helpers

def _get_current_platform():
    # type: () -> str
    if "darwin" in sys.platform:
        return MACOS
    elif "linux" in sys.platform:
        return LINUX
    else:
        raise Exception("Platform not supported %s" % sys.platform)

# Main

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Install scripts on the current system.")
    parser.add_argument("action", choices=["list", "run"], help="whether to list the tasks or actually run them")
    parser.add_argument("-b", "--basic", action="store_true", help="only include basic tasks")
    parser.add_argument("-p", "--platform", action="store", help="the platform to use")
    args = parser.parse_args()

    module_name = __name__
    tags = []

    platform = args.platform if args.platform else _get_current_platform()
    assert platform in ALL_PLATFORMS, "Unknown platform: %s" % platform
    tags.append(platform)

    if args.basic:
        tags.append(BASIC)

    config = ExecutorConfig(module_name, tags)

    if args.action == "list":
        print_all_tasks_for_config(config)
    elif args.action == "run":
        run_all_tasks_for_config(config)
